<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于 gitignore 文件过滤无效-不能过滤某些文件问题]]></title>
    <url>%2F2015%2F02%2F05%2Fabout-gitignore-problem%2F</url>
    <content type="text"><![CDATA[利用 .gitignore 过滤文件，如编译过程中的中间文件等等，这些文件不需要被追踪管理，需要被忽略掉。 问题:在 .gitignore 中添加 FileSample 文件，以过滤该文件，但是通过 git status 查看仍显示 FileSample 文件的更改状态。原因：.gitignore 文件只对还没有加入版本管理的文件起作用，若之前已经这些文件纳入了版本库，就不起作用了解决办法：需要在 git 库中删除该文件，并更新。 再次 git status 查看状态，FileSample 文件不再显示更改状态，也就是不再追踪变化，gitignore 起作用了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python排序高级]]></title>
    <url>%2F2015%2F01%2F30%2Fpython-how-to-sorting%2F</url>
    <content type="text"><![CDATA[Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。 1）排序基础简单的升序排序是非常容易的。只需要调用sorted()方法。它返回一个新的list，新的list的元素基于小于运算符(lt)来排序。12&gt;&gt;&gt;sorted([5, 2, 3, 1, 4])[1, 2, 3, 4, 5] 你也可以使用list.sort()方法来排序，此时list本身将被修改。通常此方法不如sorted()方便，但是如果你不需要保留原来的list，此方法将更有效。1234&gt;&gt;&gt; a = [5, 2, 3, 1, 4]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4, 5] 另一个不同就是list.sort()方法仅被定义在list中，相反地sorted()方法对所有的可迭代序列都有效。12&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;)[1, 2, 3, 4, 5] 2）key参数/函数 从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：12&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。 更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如： 1234567&gt;&gt;&gt; student_tuples = [ ('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 同样的技术对拥有命名属性的复杂对象也适用，例如： 1234567891011121314&gt;&gt;&gt; class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))&gt;&gt;&gt; student_objects = [ Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 3）Operator 模块函数 上面的key参数的使用非常广泛，因此python提供了一些方便的函数来使得访问方法更加容易和快速。operator模块有itemgetter，attrgetter，从2.6开始还增加了methodcaller方法。使用这些方法，上面的操作将变得更加简洁和快速：12345&gt;&gt;&gt; from operator import itemgetter, attrgetter&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2))[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'))[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] operator模块还允许多级的排序，例如，先以grade，然后再以age来排序：1234&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(1,2))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('grade', 'age'))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)] 4）升序和降序 list.sort()和sorted()都接受一个参数reverse（True or False）来表示升序或降序排序。例如对上面的student降序排序如下：1234&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2), reverse=True)[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'), reverse=True)[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] 5）排序的稳定性和复杂排序 从python2.2开始，排序被保证为稳定的。意思是说多个元素如果有相同的key，则排序前后他们的先后顺序不变。123&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]&gt;&gt;&gt; sorted(data, key=itemgetter(0))[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)] 注意在排序后’blue’的顺序被保持了，即’blue’, 1在’blue’, 2的前面。 更复杂地你可以构建多个步骤来进行更复杂的排序，例如对student数据先以grade降序排列，然后再以age升序排列。123&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age')) # sort on secondary key&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True) # now sort on primary key, descending[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 6）最老土的排序方法-DSU我们称其为DSU（Decorate-Sort-Undecorate）,原因为排序的过程需要下列三步：第一：对原始的list进行装饰，使得新list的值可以用来控制排序；第二：对装饰后的list排序；第三：将装饰删除，将排序后的装饰list重新构建为原来类型的list； 例如，使用DSU方法来对student数据根据grade排序：1234&gt;&gt;&gt; decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]&gt;&gt;&gt; decorated.sort()&gt;&gt;&gt; [student for grade, i, student in decorated] # undecorate[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] 上面的比较能够工作，原因是tuples是可以用来比较，tuples间的比较首先比较tuples的第一个元素，如果第一个相同再比较第二个元素，以此类推。 并不是所有的情况下都需要在以上的tuples中包含索引，但是包含索引可以有以下好处：第一：排序是稳定的，如果两个元素有相同的key，则他们的原始先后顺序保持不变；第二：原始的元素不必用来做比较，因为tuples的第一和第二元素用来比较已经是足够了。 此方法被RandalL.在perl中广泛推广后，他的另一个名字为也被称为Schwartzian transform。 对大的list或list的元素计算起来太过复杂的情况下，在python2.4前，DSU很可能是最快的排序方法。但是在2.4之后，上面解释的key函数提供了类似的功能。 7）其他语言普遍使用的排序方法-cmp函数在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数。此方法在其他语言中也普遍存在。 在python3.0中，cmp参数被彻底的移除了，从而简化和统一语言，减少了高级比较和cmp方法的冲突。 在python2.x中cmp参数指定的函数用来进行元素间的比较。此函数需要2个参数，然后返回负数表示小于，0表示等于，正数表示大于。例如：1234&gt;&gt;&gt; def numeric_compare(x, y): return x - y&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)[1, 2, 3, 4, 5] 或者你可以反序排序：1234&gt;&gt;&gt; def reverse_numeric(x, y): return y - x&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)[5, 4, 3, 2, 1] 当我们将现有的2.x的代码移植到3.x时，需要将cmp函数转化为key函数，以下的wrapper很有帮助： 123456789101112131415161718def cmp_to_key(mycmp): 'Convert a cmp= function into a key= function' class K(object): def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) &lt; 0 def __gt__(self, other): return mycmp(self.obj, other.obj) &gt; 0 def __eq__(self, other): return mycmp(self.obj, other.obj) == 0 def __le__(self, other): return mycmp(self.obj, other.obj) &lt;= 0 def __ge__(self, other): return mycmp(self.obj, other.obj) &gt;= 0 def __ne__(self, other): return mycmp(self.obj, other.obj) != 0 return K 当需要将cmp转化为key时，只需要：12&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))[5, 4, 3, 2, 1] 从python2.7，cmp_to_key()函数被增加到了functools模块中。 8)其他注意事项 对需要进行区域相关的排序时，可以使用locale.strxfrm()作为key函数，或者使用local.strcoll()作为cmp函数。 reverse参数任然保持了排序的稳定性，有趣的时，同样的效果可以使用reversed()函数两次来实现： 12&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]&gt;&gt;&gt; assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data)))) 其实排序在内部是调用元素的cmp来进行的，所以我们可以为元素类型增加cmp方法使得元素可比较，例如： 123&gt;&gt;&gt; Student.__lt__ = lambda self, other: self.age &lt; other.age&gt;&gt;&gt; sorted(student_objects)[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] key函数不仅可以访问需要排序元素的内部数据，还可以访问外部的资源，例如，如果学生的成绩是存储在dictionary中的，则可以使用此dictionary来对学生名字的list排序，如下： 1234&gt;&gt;&gt; students = ['dave', 'john', 'jane']&gt;&gt;&gt; newgrades = &#123;'john': 'F', 'jane':'A', 'dave': 'C'&#125;&gt;&gt;&gt; sorted(students, key=newgrades.__getitem__)['jane', 'dave', 'john'] *当你需要在处理数据的同时进行排序的话，sort(),sorted()或bisect.insort()不是最好的方法。在这种情况下，可以使用heap，red-black tree或treap。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中xrange和range区别]]></title>
    <url>%2F2015%2F01%2F29%2Fdiff-xrange-range%2F</url>
    <content type="text"><![CDATA[xrange和range区别:这两个基本上都是在循环的时候用。12345for i in range(0, 100): print ifor i in xrange(0, 100): print i 这两个输出的结果都是一样的，实际上有很多不同，range会直接生成一个list对象：1234567&gt;&gt;&gt; a = range(0,100)&gt;&gt;&gt; print type(a)&lt;type 'list'&gt;&gt;&gt;&gt; print a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]&gt;&gt;&gt; print a[0], a[1]0 1 而xrange则不会直接生成一个list，而是每次调用返回其中的一个值1234567&gt;&gt;&gt; a = xrange(0,100)&gt;&gt;&gt; print type(a)&lt;type 'xrange'&gt;&gt;&gt;&gt; print axrange(100)&gt;&gt;&gt; print a[0], a[1]0 1 所以xrange做循环的性能比range好，尤其是返回很大的时候！ 尽量用xrange吧，除非你是要返回一个列表。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORA-00904-标识符无效解决办法]]></title>
    <url>%2F2015%2F01%2F28%2FORA-00904-%E6%A0%87%E8%AF%86%E7%AC%A6%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[出现此错误首先检查输入的字段名与数据库的表中的字段名是否一样。如果一样，就要检查下表的字段名的大小写了，如果用navicat等图形化管理工具建表时，字段名写成了小写，那么今后查询此表时就同样要用小写，但是在命令行内oracle数据库后自动将小写转换为大写再接收，所以需要给小写的字段名加上引号才能查询成功。C#用调用时也一样，由于oracle接收字符串都会将小写转化为大写，所以也很可能出现标识符无效的错误。所以在建表时字段名最好都用大写，尤其当用图形化工具建表时更要注意这一点。 现在举一个遇到的例子：1insert into SSQX_SURGERY_INFO (ID, PackId, REMARK, DEPARTID, AMOUNT, PRIORITY) values (3, 11, '1rt', 1, 1, 'fdg') 一直报PackId是无效标识符改成&quot;PackId&quot;即可1insert into SSQX_SURGERY_INFO (ID, ”PackId“, REMARK, DEPARTID, AMOUNT, PRIORITY) values (3, 11, '1rt', 1, 1, 'fdg')]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText快捷键列表]]></title>
    <url>%2F2015%2F01%2F23%2FSublimeText-Shortcuts-Cheatsheet%2F</url>
    <content type="text"><![CDATA[快捷键列表（Shortcuts Cheatsheet）通用（General） ↑↓←→：上下左右移动光标，注意不是不是KJHL！ Alt：调出菜单 Ctrl + Shift + P：调出命令板（Command Palette） Ctrl +：调出控制台 编辑（Editing） Ctrl + Enter：在当前行下面新增一行然后跳至该行 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行 Ctrl + ←/→：进行逐词移动 Ctrl + Shift + ←/→：进行逐词选择 Ctrl + ↑/↓：移动当前显示区域 Ctrl + Shift + ↑/↓：移动当前行 选择（Selecting） Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑 Ctrl + Shift + L ：将当前选中区域打散 Ctrl + J ：把当前选中区域合并为一行 Ctrl + M ：在起始括号和结尾括号间切换 Ctrl + Shift + M ：快速选择括号间的内容 Ctrl + Shift + J ：快速选择同缩进的内容 Ctrl + Shift + Spac e ：快速选择当前作用域（Scope）的内容 查找&amp;替换（Finding&amp;Replacing） F3 ：跳至当前关键字下一个位置 Shift + F3 ：跳到当前关键字上一个位置 Alt + F3 ：选中当前关键字出现的所有位置 Ctrl + F/H ：进行标准查找/替换，之后： Alt + C ：切换大小写敏感（Case-sensitive）模式 Alt + W ：切换整字匹配（Whole matching）模式 Alt + R ：切换正则匹配（Regex matching）模式 Ctrl + Shift + H ：替换当前关键字 Ctrl + Alt + Enter ：替换所有关键字匹配 Ctrl + Shift + F ：多文件搜索&amp;替换 跳转（Jumping） Ctrl + P：跳转到指定文件，输入文件名后可以： @ 符号跳转：输入@symbol跳转到symbol符号所在的位置 # 关键字跳转：输入#keyword跳转到keyword所在的位置 : 行号跳转：输入:12跳转到文件的第12行。 Ctrl + R：跳转到指定符号 Ctrl + G：跳转到指定行号 窗口（Window） Ctrl + Shift + N：创建一个新窗口 Ctrl + N：在当前窗口创建一个新标签 Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口 Ctrl + Shift + T：恢复刚刚关闭的标签 屏幕（Screen） F11 ：切换普通全屏 Shift + F11 ：切换无干扰全屏 Alt + Shift + 2 ：进行左右分屏 Alt + Shift + 8 ：进行上下分屏 Alt + Shift + 5 ：进行上下左右分屏 分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏]]></content>
      <categories>
        <category>Editer</category>
      </categories>
      <tags>
        <tag>SublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串格式化]]></title>
    <url>%2F2015%2F01%2F17%2Fpython-format-string%2F</url>
    <content type="text"><![CDATA[Python格式操作符格式操作符为真实值预留位置，并控制显示的格式。格式符可以包含有一个类型码，用以控制显示类型，常见类型如下:1234567891011121314151617181920212223242526272829%s 字符串 (采用str()的显示)%r 字符串 (采用repr()的显示)%c 单个字符%b 二进制整数%d 十进制整数%i 十进制整数%o 八进制整数%x 十六进制整数%e 指数 (基底写为e)%E 指数 (基底写为E)%f 浮点数%F 浮点数，与上相同%g 指数(e)或浮点数 (根据显示长度)%G 指数(E)或浮点数 (根据显示长度)%% 字符&quot;%&quot; 使用方法%[(name)][flags][width].[precision]typecode (name)：为名称 flags：可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。 width：表示显示宽度 precision：表示小数点后精度 例如： 123print("%+10x" % 10)print("%04d" % 5)print("%6.3f" % 2.3) 上面的width, precision为两个整数。我们可以利用*，来动态代入这两个量。比如： print(&quot;%.*f&quot; % (4, 1.2)) Python实际上用4来替换*。所以实际的模板为”%.4f”。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
