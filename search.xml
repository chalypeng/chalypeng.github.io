<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[德鲁克谈《自我管理》——《哈佛商业评论》史上最受欢迎的文章]]></title>
    <url>%2F2018%2F06%2F25%2FManagin-Oneself%2F</url>
    <content type="text"><![CDATA[《管理自己》，洋文叫做《 Managing Oneself 》。此文刊登在十年前（2008）的《哈佛商业评论》（HBR）上，号称是 HBR“有屎以来”（创刊后）重印次数最多的文章。 这篇《 Managing Oneself 》实际上是摘自“彼得·德鲁克”（Peter F. Drucker）1999年出版的《21世纪的管理挑战》一书的第6章（也是最后一章）。 为啥分享此文？因为【这篇长文对每个人都很有帮助】。通过此文的借鉴，可以帮助你更好地规划自己的职业生涯和人生。 ★0、前言 我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。 不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。 历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。 我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。 ★1、我的长处是什么？ 多数人都以为他们知道自己擅长什么，其实不然！更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情。 以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。 ​ 要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。 比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。 回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。 ​ 我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。 在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。 根据回馈分析的启示，你需要在几方面采取行动。 首先，最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。 其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。 第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。 ​ 另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。 与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。 把预期和实际结果进行比较，也会发现自己不擅长做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为“从无能到平庸”要比“从一流到卓越”需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。 ★2、我的工作方式是怎样的？ 令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。 同一个人的长处一样，一个人的工作方式也是独一无二的——这是由人的个性所决定的。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。 我属于读者型，还是听者型？ 首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有“读者型”和“听者型”之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。 德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。 艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。 几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。 没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力；反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。 ★3、我如何学习？ ​ 要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。 许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。 所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。 像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。 我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。 在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。 我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？ 有些人适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长（可能也是美国历史上最成功的伯乐）乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。” 一些人作为团队成员工作最出色；另一些人单独工作最出色。一些人当教练和导师特别有天赋；另一些人却没能力做导师。 另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？ 许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。 顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。 其他有助于认识自我的重要问题包括： 1、我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？2、我是在一个大公司还是在一个小公司中工作表现最佳？3、在各种环境下都工作出色的人寥寥无几。 我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。 ★4、我的价值观是什么？ 要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。 20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。”——这就是镜子测试。 我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。 ​ 如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。 让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。 同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。 至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。 价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，其衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。 这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题（至少首先并不是神学问题），而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。”而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。” ​ 组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。 一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。 如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。 ★5、我属于何处？ 少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案： 1、我的长处是什么？2、我的工作方式是怎样的？3、我的价值观是什么？ 随后，他们就能够决定自己该向何处投入精力。或者，他们应该能够决定自己不属于何处。 已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。 同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。他们会说：“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。” ​ 成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。 ★6、我该做什么贡献？ 综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。 以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”，organization man）还指望公司的人事部为他们做职业规划。 随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。 尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素： 1、当前形势的要求是什么？2、鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？3、必须取得什么结果才能产生重要影响？ 请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。 正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是： 1、我在哪些方面能取得将在今后一年半内见效的结果？2、如何取得这样的结果？ 回答这个问题时必须对几个方面进行权衡： 首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力”（stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。 其次，这些结果应该富有意义，要能够产生一定影响。 最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。 ★7、我要如何处理人际关系？ 除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。 首先是要接受：别人是和你一样的个体这个事实。 每个人都会执意展现自己作为人的个性。这就是说，每个人都有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。 一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。 老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，以适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。 这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。 人际关系责任的第二部分内容是沟通责任。 在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。 在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。 而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。 如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。 即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？” 如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？” ​ 组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。 ★8、我该如何管理后半生？ 当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。 我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。 发展第二职业有三种方式： 第一种是完全投身于新工作。 这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。 为后半生做准备的第二种方式是，发展一个平行的职业。 许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。 最后一种方法是社会创业。 社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。 ​ 能管理好自己后半生的人总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。 ​ 管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。 同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。 发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——还可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。 在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。 自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。 历史上每一个社会，甚至是个人主义倾向最强的社会，都认为（即使只是下意识地认为）两件事情是理所当然的： 1、组织比员工更长寿；2、大多数人从不挪地方。 如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命。 本文自：编程随想 原始地址]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 gitignore 文件过滤无效-不能过滤某些文件问题]]></title>
    <url>%2F2015%2F02%2F05%2Fabout-gitignore-problem%2F</url>
    <content type="text"><![CDATA[利用 .gitignore 过滤文件，如编译过程中的中间文件等等，这些文件不需要被追踪管理，需要被忽略掉。 问题:在 .gitignore 中添加 FileSample 文件，以过滤该文件，但是通过 git status 查看仍显示 FileSample 文件的更改状态。原因：.gitignore 文件只对还没有加入版本管理的文件起作用，若之前已经这些文件纳入了版本库，就不起作用了解决办法：需要在 git 库中删除该文件，并更新。 再次 git status 查看状态，FileSample 文件不再显示更改状态，也就是不再追踪变化，gitignore 起作用了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python排序高级]]></title>
    <url>%2F2015%2F01%2F30%2Fpython-how-to-sorting%2F</url>
    <content type="text"><![CDATA[Python list内置sort()方法用来排序，也可以用python内置的全局sorted()方法来对可迭代的序列排序生成新的序列。 1）排序基础简单的升序排序是非常容易的。只需要调用sorted()方法。它返回一个新的list，新的list的元素基于小于运算符(lt)来排序。12&gt;&gt;&gt;sorted([5, 2, 3, 1, 4])[1, 2, 3, 4, 5] 你也可以使用list.sort()方法来排序，此时list本身将被修改。通常此方法不如sorted()方便，但是如果你不需要保留原来的list，此方法将更有效。1234&gt;&gt;&gt; a = [5, 2, 3, 1, 4]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1, 2, 3, 4, 5] 另一个不同就是list.sort()方法仅被定义在list中，相反地sorted()方法对所有的可迭代序列都有效。12&gt;&gt;&gt; sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;)[1, 2, 3, 4, 5] 2）key参数/函数 从python2.4开始，list.sort()和sorted()函数增加了key参数来指定一个函数，此函数将在每个元素比较前被调用。 例如通过key指定的函数来忽略字符串的大小写：12&gt;&gt;&gt; sorted("This is a test string from Andrew".split(), key=str.lower)['a', 'Andrew', 'from', 'is', 'string', 'test', 'This'] key参数的值为一个函数，此函数只有一个参数且返回一个值用来进行比较。这个技术是快速的因为key指定的函数将准确地对每个元素调用。 更广泛的使用情况是用复杂对象的某些值来对复杂对象的序列排序，例如： 1234567&gt;&gt;&gt; student_tuples = [ ('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 同样的技术对拥有命名属性的复杂对象也适用，例如： 1234567891011121314&gt;&gt;&gt; class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age))&gt;&gt;&gt; student_objects = [ Student('john', 'A', 15), Student('jane', 'B', 12), Student('dave', 'B', 10),]&gt;&gt;&gt; sorted(student_objects, key=lambda student: student.age) # sort by age[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 3）Operator 模块函数 上面的key参数的使用非常广泛，因此python提供了一些方便的函数来使得访问方法更加容易和快速。operator模块有itemgetter，attrgetter，从2.6开始还增加了methodcaller方法。使用这些方法，上面的操作将变得更加简洁和快速：12345&gt;&gt;&gt; from operator import itemgetter, attrgetter&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2))[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'))[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] operator模块还允许多级的排序，例如，先以grade，然后再以age来排序：1234&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(1,2))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('grade', 'age'))[('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)] 4）升序和降序 list.sort()和sorted()都接受一个参数reverse（True or False）来表示升序或降序排序。例如对上面的student降序排序如下：1234&gt;&gt;&gt; sorted(student_tuples, key=itemgetter(2), reverse=True)[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]&gt;&gt;&gt; sorted(student_objects, key=attrgetter('age'), reverse=True)[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] 5）排序的稳定性和复杂排序 从python2.2开始，排序被保证为稳定的。意思是说多个元素如果有相同的key，则排序前后他们的先后顺序不变。123&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]&gt;&gt;&gt; sorted(data, key=itemgetter(0))[('blue', 1), ('blue', 2), ('red', 1), ('red', 2)] 注意在排序后’blue’的顺序被保持了，即’blue’, 1在’blue’, 2的前面。 更复杂地你可以构建多个步骤来进行更复杂的排序，例如对student数据先以grade降序排列，然后再以age升序排列。123&gt;&gt;&gt; s = sorted(student_objects, key=attrgetter('age')) # sort on secondary key&gt;&gt;&gt; sorted(s, key=attrgetter('grade'), reverse=True) # now sort on primary key, descending[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 6）最老土的排序方法-DSU我们称其为DSU（Decorate-Sort-Undecorate）,原因为排序的过程需要下列三步：第一：对原始的list进行装饰，使得新list的值可以用来控制排序；第二：对装饰后的list排序；第三：将装饰删除，将排序后的装饰list重新构建为原来类型的list； 例如，使用DSU方法来对student数据根据grade排序：1234&gt;&gt;&gt; decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]&gt;&gt;&gt; decorated.sort()&gt;&gt;&gt; [student for grade, i, student in decorated] # undecorate[('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)] 上面的比较能够工作，原因是tuples是可以用来比较，tuples间的比较首先比较tuples的第一个元素，如果第一个相同再比较第二个元素，以此类推。 并不是所有的情况下都需要在以上的tuples中包含索引，但是包含索引可以有以下好处：第一：排序是稳定的，如果两个元素有相同的key，则他们的原始先后顺序保持不变；第二：原始的元素不必用来做比较，因为tuples的第一和第二元素用来比较已经是足够了。 此方法被RandalL.在perl中广泛推广后，他的另一个名字为也被称为Schwartzian transform。 对大的list或list的元素计算起来太过复杂的情况下，在python2.4前，DSU很可能是最快的排序方法。但是在2.4之后，上面解释的key函数提供了类似的功能。 7）其他语言普遍使用的排序方法-cmp函数在python2.4前，sorted()和list.sort()函数没有提供key参数，但是提供了cmp参数来让用户指定比较函数。此方法在其他语言中也普遍存在。 在python3.0中，cmp参数被彻底的移除了，从而简化和统一语言，减少了高级比较和cmp方法的冲突。 在python2.x中cmp参数指定的函数用来进行元素间的比较。此函数需要2个参数，然后返回负数表示小于，0表示等于，正数表示大于。例如：1234&gt;&gt;&gt; def numeric_compare(x, y): return x - y&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=numeric_compare)[1, 2, 3, 4, 5] 或者你可以反序排序：1234&gt;&gt;&gt; def reverse_numeric(x, y): return y - x&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)[5, 4, 3, 2, 1] 当我们将现有的2.x的代码移植到3.x时，需要将cmp函数转化为key函数，以下的wrapper很有帮助： 123456789101112131415161718def cmp_to_key(mycmp): 'Convert a cmp= function into a key= function' class K(object): def __init__(self, obj, *args): self.obj = obj def __lt__(self, other): return mycmp(self.obj, other.obj) &lt; 0 def __gt__(self, other): return mycmp(self.obj, other.obj) &gt; 0 def __eq__(self, other): return mycmp(self.obj, other.obj) == 0 def __le__(self, other): return mycmp(self.obj, other.obj) &lt;= 0 def __ge__(self, other): return mycmp(self.obj, other.obj) &gt;= 0 def __ne__(self, other): return mycmp(self.obj, other.obj) != 0 return K 当需要将cmp转化为key时，只需要：12&gt;&gt;&gt; sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))[5, 4, 3, 2, 1] 从python2.7，cmp_to_key()函数被增加到了functools模块中。 8)其他注意事项 对需要进行区域相关的排序时，可以使用locale.strxfrm()作为key函数，或者使用local.strcoll()作为cmp函数。 reverse参数任然保持了排序的稳定性，有趣的时，同样的效果可以使用reversed()函数两次来实现： 12&gt;&gt;&gt; data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]&gt;&gt;&gt; assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data)))) 其实排序在内部是调用元素的cmp来进行的，所以我们可以为元素类型增加cmp方法使得元素可比较，例如： 123&gt;&gt;&gt; Student.__lt__ = lambda self, other: self.age &lt; other.age&gt;&gt;&gt; sorted(student_objects)[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] key函数不仅可以访问需要排序元素的内部数据，还可以访问外部的资源，例如，如果学生的成绩是存储在dictionary中的，则可以使用此dictionary来对学生名字的list排序，如下： 1234&gt;&gt;&gt; students = ['dave', 'john', 'jane']&gt;&gt;&gt; newgrades = &#123;'john': 'F', 'jane':'A', 'dave': 'C'&#125;&gt;&gt;&gt; sorted(students, key=newgrades.__getitem__)['jane', 'dave', 'john'] *当你需要在处理数据的同时进行排序的话，sort(),sorted()或bisect.insort()不是最好的方法。在这种情况下，可以使用heap，red-black tree或treap。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中xrange和range区别]]></title>
    <url>%2F2015%2F01%2F29%2Fdiff-xrange-range%2F</url>
    <content type="text"><![CDATA[xrange和range区别:这两个基本上都是在循环的时候用。12345for i in range(0, 100): print ifor i in xrange(0, 100): print i 这两个输出的结果都是一样的，实际上有很多不同，range会直接生成一个list对象：1234567&gt;&gt;&gt; a = range(0,100)&gt;&gt;&gt; print type(a)&lt;type 'list'&gt;&gt;&gt;&gt; print a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]&gt;&gt;&gt; print a[0], a[1]0 1 而xrange则不会直接生成一个list，而是每次调用返回其中的一个值1234567&gt;&gt;&gt; a = xrange(0,100)&gt;&gt;&gt; print type(a)&lt;type 'xrange'&gt;&gt;&gt;&gt; print axrange(100)&gt;&gt;&gt; print a[0], a[1]0 1 所以xrange做循环的性能比range好，尤其是返回很大的时候！ 尽量用xrange吧，除非你是要返回一个列表。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORA-00904-标识符无效解决办法]]></title>
    <url>%2F2015%2F01%2F28%2FORA-00904-%E6%A0%87%E8%AF%86%E7%AC%A6%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[出现此错误首先检查输入的字段名与数据库的表中的字段名是否一样。如果一样，就要检查下表的字段名的大小写了，如果用navicat等图形化管理工具建表时，字段名写成了小写，那么今后查询此表时就同样要用小写，但是在命令行内oracle数据库后自动将小写转换为大写再接收，所以需要给小写的字段名加上引号才能查询成功。C#用调用时也一样，由于oracle接收字符串都会将小写转化为大写，所以也很可能出现标识符无效的错误。所以在建表时字段名最好都用大写，尤其当用图形化工具建表时更要注意这一点。 现在举一个遇到的例子：1insert into SSQX_SURGERY_INFO (ID, PackId, REMARK, DEPARTID, AMOUNT, PRIORITY) values (3, 11, '1rt', 1, 1, 'fdg') 一直报PackId是无效标识符改成&quot;PackId&quot;即可1insert into SSQX_SURGERY_INFO (ID, ”PackId“, REMARK, DEPARTID, AMOUNT, PRIORITY) values (3, 11, '1rt', 1, 1, 'fdg')]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText快捷键列表]]></title>
    <url>%2F2015%2F01%2F23%2FSublimeText-Shortcuts-Cheatsheet%2F</url>
    <content type="text"><![CDATA[快捷键列表（Shortcuts Cheatsheet）通用（General） ↑↓←→：上下左右移动光标，注意不是不是KJHL！ Alt：调出菜单 Ctrl + Shift + P：调出命令板（Command Palette） Ctrl +：调出控制台 编辑（Editing） Ctrl + Enter：在当前行下面新增一行然后跳至该行 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行 Ctrl + ←/→：进行逐词移动 Ctrl + Shift + ←/→：进行逐词选择 Ctrl + ↑/↓：移动当前显示区域 Ctrl + Shift + ↑/↓：移动当前行 选择（Selecting） Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑 Ctrl + Shift + L ：将当前选中区域打散 Ctrl + J ：把当前选中区域合并为一行 Ctrl + M ：在起始括号和结尾括号间切换 Ctrl + Shift + M ：快速选择括号间的内容 Ctrl + Shift + J ：快速选择同缩进的内容 Ctrl + Shift + Spac e ：快速选择当前作用域（Scope）的内容 查找&amp;替换（Finding&amp;Replacing） F3 ：跳至当前关键字下一个位置 Shift + F3 ：跳到当前关键字上一个位置 Alt + F3 ：选中当前关键字出现的所有位置 Ctrl + F/H ：进行标准查找/替换，之后： Alt + C ：切换大小写敏感（Case-sensitive）模式 Alt + W ：切换整字匹配（Whole matching）模式 Alt + R ：切换正则匹配（Regex matching）模式 Ctrl + Shift + H ：替换当前关键字 Ctrl + Alt + Enter ：替换所有关键字匹配 Ctrl + Shift + F ：多文件搜索&amp;替换 跳转（Jumping） Ctrl + P：跳转到指定文件，输入文件名后可以： @ 符号跳转：输入@symbol跳转到symbol符号所在的位置 # 关键字跳转：输入#keyword跳转到keyword所在的位置 : 行号跳转：输入:12跳转到文件的第12行。 Ctrl + R：跳转到指定符号 Ctrl + G：跳转到指定行号 窗口（Window） Ctrl + Shift + N：创建一个新窗口 Ctrl + N：在当前窗口创建一个新标签 Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口 Ctrl + Shift + T：恢复刚刚关闭的标签 屏幕（Screen） F11 ：切换普通全屏 Shift + F11 ：切换无干扰全屏 Alt + Shift + 2 ：进行左右分屏 Alt + Shift + 8 ：进行上下分屏 Alt + Shift + 5 ：进行上下左右分屏 分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏]]></content>
      <categories>
        <category>Editer</category>
      </categories>
      <tags>
        <tag>SublimeText</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串格式化]]></title>
    <url>%2F2015%2F01%2F17%2Fpython-format-string%2F</url>
    <content type="text"><![CDATA[Python格式操作符格式操作符为真实值预留位置，并控制显示的格式。格式符可以包含有一个类型码，用以控制显示类型，常见类型如下:1234567891011121314151617181920212223242526272829%s 字符串 (采用str()的显示)%r 字符串 (采用repr()的显示)%c 单个字符%b 二进制整数%d 十进制整数%i 十进制整数%o 八进制整数%x 十六进制整数%e 指数 (基底写为e)%E 指数 (基底写为E)%f 浮点数%F 浮点数，与上相同%g 指数(e)或浮点数 (根据显示长度)%G 指数(E)或浮点数 (根据显示长度)%% 字符&quot;%&quot; 使用方法%[(name)][flags][width].[precision]typecode (name)：为名称 flags：可以有+,-,’ ‘或0。+表示右对齐。-表示左对齐。’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。0表示使用0填充。 width：表示显示宽度 precision：表示小数点后精度 例如： 123print("%+10x" % 10)print("%04d" % 5)print("%6.3f" % 2.3) 上面的width, precision为两个整数。我们可以利用*，来动态代入这两个量。比如： print(&quot;%.*f&quot; % (4, 1.2)) Python实际上用4来替换*。所以实际的模板为”%.4f”。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
